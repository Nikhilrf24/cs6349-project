# CS6349 - Project

This is a simple file storage project following the client-server model of communication written over plain TCP sockets with security enhancements satisfying the project requirements

### Requirements and Fulfillments

1. File upload/download functionality
   - Implemented using the `TCP protocol` which provides connection packet order guarantees when compared to the UDP protocol
2. Authentication: The clients should be able to authenticate the server
   - We used `X.509 certificate` based authentication for the server
3. Confidentiality: Communication between the parties involved should be secure
   - Implemented using the `SHA-256` hashing algorithm
4. Integrity: Every packet should be verified for integrity
   - Implemented using the `HMAC-SHA256` algorithm
   - Protocol utilizes `round` and `counter` variables (separate for ingress and egress traffic) which are checked for each packet

### Tech

- Node.js - Socket programming
- RSA, SHA-256 and HMAC-SHA256
- Custom Encryption Algorithm using SHA-256 Algorithm

### Protocol

##### Message Format

Before encryption, the packet stores the following information

1. `type`: Message Type
2. `data`: Message Data
3. `round`: An integer value which is incremented once every time the counter value needs to be reset
4. `counter`: An integer value used to keep track of the `nth` message sent/received on a connection

The digest is calculated by concatenating the original message fields (above) and sending it through the HMAC-SHA256 algorithm.
The payload along with the digest is encrypted using the custom encryption algorithm and sent on the connection.

##### Authentication

1. On initial connection from the client, the server sends out it's `X509 certificate` along with a `timestamp` signed with their private key
2. The client verifies the certificate with the CA and the timestamp with the public key of the server and `generates four session keys` (two for encryption and two for generating keyed-hashes) and responds (encrypted with the server's public key) with the following data
   - `32 byte random nonce` used as a `seed` to generate session keys
   - The `timestamp` sent by the server (Used by the server to validate the initial)
   - Additional details about the request such as `file metadata` etc.

##### Integrity

1. For integrity, we're using the Keyed Hash `HMAC-SHA-256` algorithm
2. The generated digest is added to the payload before encryption
3. After successful decryption, the processor verifies the data with the digest and breaks the connection if it fails

##### Confidentiality

1. For encryption, we use a custom encryption algorithm (a form of `stream cipher`)
2. Every packet is encrypted with a `Unique Key` which is generated by using `two values`
   1. `Key` takes from the generated keys or previously encrypted cipher text if it exists
   2. `IV` taken from the Signing Key else the current cipher key is used as the next round's IV
3. Decryption follows a similar pattern except in reverse

### Attack Scenarios and Mitigations

TODO
